# Explore JS part/course.
   - Execution Context
   - How JS is executed & Call Stack
   - Hoisting in JS (variables & functions)
   - Functions and variable environments
   - Undefined vs not defined in JS
   - The Scope Chain, Scope & Lexical Environment
   - let & const in JS, Temporal Dead Zone
   - Block Scope & Shadowing in JS
   - Closures in JS
   - setTimeout + Closures
   - Questions Closures
   - Functions Statement
   - Functions Expression
   - Functions Declaration
   - Anonymous Functions
   - Named Functions Expression
   - Different between Parameters & Arguments
   - First Class Functions/Citizens
   - Arrow Functions
   - Callback Functions
   - Event Listeners
   - Asynchronous JavaScript & EVENT LOOP from scratch
      - How JS Engine Executes the Code using Call Stack
      - Main Job of the Call Stack
      - How does JavaScript perform async tasks
      - Behind the Scenes in Browser
      - Web APIs in JS
      - How setTimeout Works behind the scenes in Browsers
      - Event Loop & CallBack/Task Queue in JS
      - How Event Listeners Work in JS
      - More about Event Loop
      - Why do we need Event Loop
      - How fetch() function works
      - MicroTask Queue in JS (Promises, MutationObserver)
      - What are MicroTasks in JS?
      - Starvation of Functions in Callback Queue
   - JS Engine Exposed, Google's V8 Architecture
      - JavaScript Runtime Environment
      - Browser and Node.js JS Runtime
      - List of JavaScript Engines
      - JS Engine Architecture
      - Syntax Parsers and Abstract Syntax Tree
      - Compilation 
      - Execution of JS Code
      - Just In Time Compilation
      - Is JavaScript Interpreted or Compiled Language?
      - Garbage Collector - Mark & Sweep Algorithm
      - Fastest JavaScript Engine
   - setTimeout() in deep leval
   - Higher-Order Functions, Functional Programming
   - Array.prototype
   - map, filter & reduce